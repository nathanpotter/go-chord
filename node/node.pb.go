// Code generated by protoc-gen-go.
// source: node.proto
// DO NOT EDIT!

/*
Package node is a generated protocol buffer package.

It is generated from these files:
	node.proto

It has these top-level messages:
	WriteRequest
	WriteResponse
	ReadRequest
	ReadResponse
	UpdateDHTRequest
	Empty
*/
package node

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type WriteRequest struct {
	Filename string `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
	Contents []byte `protobuf:"bytes,2,opt,name=contents,proto3" json:"contents,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (m *WriteRequest) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type WriteResponse struct {
	Filename string `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
	N        int32  `protobuf:"varint,2,opt,name=n" json:"n,omitempty"`
}

func (m *WriteResponse) Reset()                    { *m = WriteResponse{} }
func (m *WriteResponse) String() string            { return proto.CompactTextString(m) }
func (*WriteResponse) ProtoMessage()               {}
func (*WriteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type ReadRequest struct {
	Filename string `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type ReadResponse struct {
	Filename string `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
	Contents []byte `protobuf:"bytes,2,opt,name=contents,proto3" json:"contents,omitempty"`
}

func (m *ReadResponse) Reset()                    { *m = ReadResponse{} }
func (m *ReadResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadResponse) ProtoMessage()               {}
func (*ReadResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type UpdateDHTRequest struct {
	Nodes []*UpdateDHTRequest_NodeInfo `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *UpdateDHTRequest) Reset()                    { *m = UpdateDHTRequest{} }
func (m *UpdateDHTRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateDHTRequest) ProtoMessage()               {}
func (*UpdateDHTRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *UpdateDHTRequest) GetNodes() []*UpdateDHTRequest_NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type UpdateDHTRequest_NodeInfo struct {
	Ip   string `protobuf:"bytes,1,opt,name=ip" json:"ip,omitempty"`
	Port int32  `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
}

func (m *UpdateDHTRequest_NodeInfo) Reset()                    { *m = UpdateDHTRequest_NodeInfo{} }
func (m *UpdateDHTRequest_NodeInfo) String() string            { return proto.CompactTextString(m) }
func (*UpdateDHTRequest_NodeInfo) ProtoMessage()               {}
func (*UpdateDHTRequest_NodeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func init() {
	proto.RegisterType((*WriteRequest)(nil), "node.WriteRequest")
	proto.RegisterType((*WriteResponse)(nil), "node.WriteResponse")
	proto.RegisterType((*ReadRequest)(nil), "node.ReadRequest")
	proto.RegisterType((*ReadResponse)(nil), "node.ReadResponse")
	proto.RegisterType((*UpdateDHTRequest)(nil), "node.UpdateDHTRequest")
	proto.RegisterType((*UpdateDHTRequest_NodeInfo)(nil), "node.UpdateDHTRequest.NodeInfo")
	proto.RegisterType((*Empty)(nil), "node.Empty")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Node service

type NodeClient interface {
	// When a client wants to write a file, it contacts the node with the
	// Write method. The node will check whether it needs to store the file
	// locally or not. if it is not the node for the filename, it will forward recursively
	Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error)
	// When a client wants to read a file, it contacts the node with the Read
	// method. The node will check whether it is the node for the filename, if not
	// it will forward the request to the other nodes recursively
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error)
	// When a node joins the DHT, it will contact the nodes in the list and let them update
	// the DHT with the new nodes list. When it's finished calling to all nodes, it will let
	// the Supernode know it's done by calling PostJoin()
	UpdateDHT(ctx context.Context, in *UpdateDHTRequest, opts ...grpc.CallOption) (*Empty, error)
}

type nodeClient struct {
	cc *grpc.ClientConn
}

func NewNodeClient(cc *grpc.ClientConn) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error) {
	out := new(WriteResponse)
	err := grpc.Invoke(ctx, "/node.Node/Write", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error) {
	out := new(ReadResponse)
	err := grpc.Invoke(ctx, "/node.Node/Read", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) UpdateDHT(ctx context.Context, in *UpdateDHTRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/node.Node/UpdateDHT", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Node service

type NodeServer interface {
	// When a client wants to write a file, it contacts the node with the
	// Write method. The node will check whether it needs to store the file
	// locally or not. if it is not the node for the filename, it will forward recursively
	Write(context.Context, *WriteRequest) (*WriteResponse, error)
	// When a client wants to read a file, it contacts the node with the Read
	// method. The node will check whether it is the node for the filename, if not
	// it will forward the request to the other nodes recursively
	Read(context.Context, *ReadRequest) (*ReadResponse, error)
	// When a node joins the DHT, it will contact the nodes in the list and let them update
	// the DHT with the new nodes list. When it's finished calling to all nodes, it will let
	// the Supernode know it's done by calling PostJoin()
	UpdateDHT(context.Context, *UpdateDHTRequest) (*Empty, error)
}

func RegisterNodeServer(s *grpc.Server, srv NodeServer) {
	s.RegisterService(&_Node_serviceDesc, srv)
}

func _Node_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/node.Node/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Write(ctx, req.(*WriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/node.Node/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Read(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_UpdateDHT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDHTRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).UpdateDHT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/node.Node/UpdateDHT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).UpdateDHT(ctx, req.(*UpdateDHTRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Node_serviceDesc = grpc.ServiceDesc{
	ServiceName: "node.Node",
	HandlerType: (*NodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Write",
			Handler:    _Node_Write_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _Node_Read_Handler,
		},
		{
			MethodName: "UpdateDHT",
			Handler:    _Node_UpdateDHT_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("node.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 282 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x52, 0xb1, 0x4e, 0xc3, 0x30,
	0x10, 0x6d, 0x4a, 0x02, 0xed, 0x25, 0x20, 0x38, 0x24, 0x54, 0x79, 0x01, 0x79, 0x2a, 0x4b, 0x90,
	0x82, 0x18, 0xd8, 0x01, 0xc1, 0xc2, 0x60, 0x81, 0x98, 0x03, 0xb9, 0x4a, 0x91, 0xa8, 0x6d, 0x62,
	0x33, 0xf4, 0x6b, 0xf8, 0x55, 0x62, 0x3b, 0x8d, 0x02, 0xaa, 0xaa, 0x6e, 0xe7, 0x77, 0x77, 0xef,
	0xde, 0x7b, 0x09, 0x80, 0x54, 0x15, 0xe5, 0xba, 0x51, 0x56, 0x61, 0xec, 0x6a, 0xfe, 0x00, 0xd9,
	0x5b, 0x53, 0x5b, 0x12, 0xf4, 0xf5, 0x4d, 0xc6, 0x22, 0x83, 0xc9, 0xa2, 0xfe, 0x24, 0x59, 0x2e,
	0x69, 0x16, 0x5d, 0x44, 0xf3, 0xa9, 0xe8, 0xdf, 0xae, 0xf7, 0xa1, 0xa4, 0x25, 0x69, 0xcd, 0x6c,
	0xdc, 0xf6, 0x32, 0xd1, 0xbf, 0xf9, 0x2d, 0x1c, 0x76, 0x3c, 0x46, 0x2b, 0x69, 0x68, 0x2b, 0x51,
	0x06, 0x91, 0xf4, 0x0c, 0x89, 0x88, 0x24, 0xbf, 0x84, 0x54, 0x50, 0x59, 0xed, 0xa0, 0xc0, 0xa9,
	0x0d, 0xa3, 0x3b, 0x1c, 0xd9, 0xa6, 0x76, 0x05, 0xc7, 0xaf, 0xba, 0x2a, 0x2d, 0xdd, 0x3d, 0xbe,
	0xac, 0xef, 0xde, 0x40, 0xe2, 0x12, 0x31, 0x2d, 0xd1, 0xde, 0x3c, 0x2d, 0xce, 0x73, 0x9f, 0xd5,
	0xff, 0xb1, 0xfc, 0xb9, 0x45, 0x9f, 0xe4, 0x42, 0x89, 0x30, 0xcd, 0x72, 0x98, 0xac, 0x21, 0x3c,
	0x82, 0x71, 0xad, 0x3b, 0x21, 0x6d, 0x85, 0x08, 0xb1, 0x56, 0x8d, 0xed, 0xac, 0xfa, 0x9a, 0x1f,
	0x40, 0x72, 0xbf, 0xd4, 0x76, 0x55, 0xfc, 0x44, 0x10, 0xbb, 0x4d, 0x2c, 0x20, 0xf1, 0xd1, 0x21,
	0x86, 0x93, 0xc3, 0xef, 0xc1, 0x4e, 0xff, 0x60, 0xc1, 0x36, 0x1f, 0xe1, 0x15, 0xc4, 0x2e, 0x08,
	0x3c, 0x09, 0xed, 0x41, 0x7e, 0x0c, 0x87, 0x50, 0xbf, 0x50, 0xc0, 0xb4, 0xb7, 0x82, 0x67, 0x9b,
	0xbd, 0xb1, 0x34, 0xe0, 0x5e, 0x1f, 0x1f, 0xbd, 0xef, 0xfb, 0x1f, 0xe5, 0xfa, 0x37, 0x00, 0x00,
	0xff, 0xff, 0x10, 0x7a, 0xfb, 0x32, 0x36, 0x02, 0x00, 0x00,
}
